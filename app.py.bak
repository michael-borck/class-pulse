import os
import json
import uuid
import csv
from datetime import datetime
from flask import Flask, render_template, request, redirect, url_for, session, jsonify, send_file
from flask_socketio import emit, join_room
from flask_socketio import ConnectionRefusedError

# Import extensions
from extensions import db, socketio
from config import Config

# Import utility functions
from utils import generate_session_code, generate_qr_code, get_join_url, export_results_to_csv

# Initialize Flask app
app = Flask(__name__)
app.config.from_object(Config)
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0  # Disable caching for static files

# Initialize extensions with the app
db.init_app(app)
socketio.init_app(app)

# Disable caching for all responses
@app.after_request
def add_no_cache_headers(response):
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

# Import models (after db initialization)
from models import User, Session, Question, Response

# Initialize database with a function to be called when the app context is available
def init_db():
    """Initialize the database and create default admin user if not exists."""
    db.create_all()
    
    # Create default admin user if it doesn't exist
    admin = User.query.filter_by(username=Config.ADMIN_USERNAME).first()
    if not admin:
        admin = User(username=Config.ADMIN_USERNAME, password=Config.ADMIN_PASSWORD)
        db.session.add(admin)
        db.session.commit()
        print(f"Created default admin user: {Config.ADMIN_USERNAME}")

# Note: We're not using @app.before_first_request as it was removed in Flask 2.3+
# Instead, we're initializing the database when the app starts up (see below)
        
# Also initialize the database when the app starts up
with app.app_context():
    try:
        init_db()
        print("Database initialized successfully")
    except Exception as e:
        print(f"Error initializing database: {e}")

# Routes
@app.route('/')
def index():
    if 'user_id' in session:
        return redirect(url_for('dashboard'))
    return redirect(url_for('login'))

@app.route('/login', methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        user = User.query.filter_by(username=username).first()
        
        if user and user.password == password:
            session['user_id'] = user.id
            session['username'] = user.username
            return redirect(url_for('dashboard'))
        else:
            error = 'Invalid credentials. Please try again.'
    
    return render_template('login.html', error=error)

@app.route('/logout')
def logout():
    session.pop('user_id', None)
    session.pop('username', None)
    return redirect(url_for('login'))

@app.route('/dashboard')
def dashboard():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    # Get active sessions
    active_sessions = Session.query.filter_by(
        user_id=session['user_id'], 
        active=True
    ).order_by(Session.created_at.desc()).all()
    
    # Get archived sessions
    archived_sessions = Session.query.filter_by(
        user_id=session['user_id'], 
        active=False
    ).order_by(Session.created_at.desc()).all()
    
    return render_template(
        'dashboard.html', 
        active_sessions=active_sessions,
        archived_sessions=archived_sessions
    )

@app.route('/create_session', methods=['POST'])
def create_session():
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    title = request.form['title']
    description = request.form.get('description', '')
    
    new_session = Session(
        title=title,
        description=description,
        code=generate_session_code(),
        user_id=session['user_id'],
        active=True
    )
    
    db.session.add(new_session)
    db.session.commit()
    
    return redirect(url_for('edit_session', session_id=new_session.id))

@app.route('/session/<int:session_id>/archive', methods=['POST'])
def archive_session(session_id):
    """Archive (deactivate) a session"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    # Archive the session
    presentation_session.active = False
    db.session.commit()
    
    return redirect(url_for('dashboard'))

@app.route('/session/<int:session_id>/restore', methods=['POST'])
def restore_session(session_id):
    """Restore (reactivate) an archived session"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    # Restore the session
    presentation_session.active = True
    db.session.commit()
    
    return redirect(url_for('dashboard'))

@app.route('/session/<int:session_id>/delete', methods=['POST'])
def delete_session(session_id):
    """Permanently delete a session and all its data"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    # Delete all related data (questions and responses)
    questions = Question.query.filter_by(session_id=session_id).all()
    for question in questions:
        # Delete responses for this question
        Response.query.filter_by(question_id=question.id).delete()
    
    # Delete questions
    Question.query.filter_by(session_id=session_id).delete()
    
    # Delete the session
    db.session.delete(presentation_session)
    db.session.commit()
    
    return redirect(url_for('dashboard'))

@app.route('/session/<int:session_id>/edit')
def edit_session(session_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    questions = Question.query.filter_by(session_id=session_id).all()
    
    return render_template(
        'dashboard.html',
        active_session=presentation_session,
        questions=questions
    )

@app.route('/session/<int:session_id>/question', methods=['POST'])
def create_question(session_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    question_text = request.form['question_text']
    question_type = request.form['question_type']
    
    # Create the new question
    new_question = Question(
        text=question_text,
        type=question_type,
        session_id=session_id
    )
    
    # If it's a multiple choice question, add options
    if question_type == 'multiple_choice':
        options = request.form.getlist('options[]')
        new_question.options = json.dumps(options)
    elif question_type == 'rating_scale':
        min_value = request.form.get('min_value', 1)
        max_value = request.form.get('max_value', 5)
        new_question.options = json.dumps({
            'min': min_value,
            'max': max_value
        })
    
    db.session.add(new_question)
    db.session.commit()
    
    return redirect(url_for('edit_session', session_id=session_id))

@app.route('/session/<int:session_id>/present')
def present_session(session_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    questions = Question.query.filter_by(session_id=session_id).all()
    
    # Generate QR code for joining
    join_url = get_join_url(presentation_session.code, request.host_url.rstrip('/'))
    qr_code_data = generate_qr_code(join_url)
    qr_code = f"data:image/png;base64,{qr_code_data}"
    
    return render_template(
        'present.html',
        presentation_session=presentation_session,
        questions=questions,
        qr_code=qr_code
    )

@app.route('/join')
def join():
    code = request.args.get('code', '')
    return render_template('join.html', code=code)

@app.route('/session/join', methods=['POST'])
def join_session():
    code = request.form['session_code']
    
    # Find the session with the given code
    presentation_session = Session.query.filter_by(code=code).first()
    
    if not presentation_session:
        return render_template('join.html', error='Invalid session code')
    
    # Set a unique identifier for this participant
    participant_id = str(uuid.uuid4())
    session['participant_id'] = participant_id
    session['session_code'] = code
    session['session_id'] = presentation_session.id
    
    return redirect(url_for('participate'))

@app.route('/participate')
def participate():
    if 'session_code' not in session:
        return redirect(url_for('join'))
    
    session_code = session['session_code']
    presentation_session = Session.query.filter_by(code=session_code).first()
    
    if not presentation_session:
        session.pop('session_code', None)
        return redirect(url_for('join'))
    
    # Get active question from the session record
    active_question = None
    
    # First check if there's an active question ID stored in the session record
    # Safely check if the attribute exists (in case migration hasn't been run)
    if hasattr(presentation_session, 'active_question_id') and presentation_session.active_question_id:
        active_question = Question.query.get(presentation_session.active_question_id)
        print(f"Found active question from session record: {active_question.text if active_question else 'None'}")
    
    # If no active question found in the session record, fall back to the most recent question
    if not active_question:
        questions = Question.query.filter_by(session_id=presentation_session.id).all()
        if questions:
            active_question = questions[-1]
            print(f"Using most recent question as active: {active_question.text}")
            
            # Update the session record with this question ID for future reference
            try:
                # Only attempt to update if the attribute exists
                if hasattr(presentation_session, 'active_question_id'):
                    presentation_session.active_question_id = active_question.id
                    db.session.commit()
                    print(f"Updated session record with active question ID: {active_question.id}")
                else:
                    print("Warning: active_question_id column not found - database migration may be needed")
            except Exception as e:
                print(f"Error updating active question ID: {e}")
                db.session.rollback()
    
    # Format active question for JavaScript
    active_question_js = None
    if active_question:
        # Parse options for the template
        if active_question.options:
            active_question.options_list = json.loads(active_question.options)
        else:
            active_question.options_list = []
            
        # Create a JSON version for JavaScript
        options = active_question.options_list
        active_question_js = {
            'id': active_question.id,
            'text': active_question.text,
            'type': active_question.type,
            'options': options
        }
        print(f"Passing active question to template: {active_question_js}")
    
    return render_template(
        'participate.html',
        presentation_session=presentation_session,
        active_question=active_question,
        active_question_js=json.dumps(active_question_js) if active_question_js else None
    )

@app.route('/session/<int:session_id>/export')
def export_results(session_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    presentation_session = Session.query.get_or_404(session_id)
    
    # Check if the session belongs to the logged-in user
    if presentation_session.user_id != session['user_id']:
        return redirect(url_for('dashboard'))
    
    # Get all questions for this session
    questions = Question.query.filter_by(session_id=session_id).all()
    
    # Prepare the questions and responses in the format needed for export_results_to_csv
    questions_data = []
    responses_data = []
    
    for question in questions:
        question_data = {
            'id': question.id,
            'text': question.text,
            'type': question.type,
            'options': json.loads(question.options) if question.options else []
        }
        questions_data.append(question_data)
        
        responses = Response.query.filter_by(question_id=question.id).all()
        for response in responses:
            response_data = {
                'question_id': question.id,
                'answer': response.value,
                'participant_id': response.participant_id[:8],
                'timestamp': response.timestamp.strftime('%Y-%m-%d %H:%M:%S')
            }
            responses_data.append(response_data)
    
    # Use the utility function to create CSV
    csv_data = export_results_to_csv(presentation_session.code, questions_data, responses_data)
    
    # Create a response and set the appropriate headers
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"classpulse_results_{presentation_session.code}_{timestamp}.csv"
    
    return send_file(
        csv_data,
        as_attachment=True,
        download_name=filename,
        mimetype='text/csv'
    )

# API routes for client-side JavaScript
@app.route('/api/question/<int:question_id>')
def get_question_details(question_id):
    question = Question.query.get_or_404(question_id)
    
    # Return question data as JSON
    return jsonify({
        'id': question.id,
        'text': question.text,
        'type': question.type,
        'options': json.loads(question.options) if question.options else []
    })

@app.route('/api/activate_question/<int:question_id>/<int:session_id>', methods=['POST', 'GET'])
def activate_question_api(question_id, session_id):
    """API endpoint to activate a question - alternative to Socket.IO"""
    print(f"HTTP API: Question {question_id} activated for session {session_id}")
    
    # Get the question details
    question = Question.query.get_or_404(question_id)
    
    # Get the session code for this session
    presentation_session = Session.query.get_or_404(session_id)
    session_code = presentation_session.code
    print(f"Question activated for session code: {session_code}")
    
    # Create room names for the session - use all possible formats for maximum reliability
    rooms = [
        f"session_{session_id}",      # Main room by session ID
        f"code_{session_code}",       # Room by session code
        f"s_{session_id}",            # Short format room
        f"c_{session_code}"           # Short format code room
    ]
    
    # Create response data
    question_details = {
        'id': question.id,
        'text': question.text,
        'type': question.type,
        'options': json.loads(question.options) if question.options else None
    }
    
    # IMPORTANT: Broadcast to all rooms for maximum reliability
    print(f"Broadcasting to multiple rooms: {', '.join(rooms)}")
    
    activation_data = {
        'question_id': question_id,
        'session_id': session_id,  # Include session ID for more context
        'session_code': session_code,  # Include session code for more context
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    
    # Broadcast to specific rooms
    for room in rooms:
        socketio.emit('question_activated', activation_data, room=room)
        socketio.emit('question_details', question_details, room=room)
    
    # Also broadcast globally for any client that might have missed room registration
    # In Flask-SocketIO, global broadcasts are done by omitting the room parameter
    socketio.emit('question_activated', activation_data)  # Global broadcast
    socketio.emit('question_details', question_details)  # Global broadcast
    
    # Fetch existing responses for this question
    responses = Response.query.filter_by(question_id=question_id).all()
    print(f"HTTP API: Found {len(responses)} existing responses for question {question_id}")
    
    response_data = {
        'question_id': question_id,
        'responses': [{'value': r.value, 'participant_id': r.participant_id} for r in responses]
    }
    
    # Update all clients with existing responses (both in rooms and globally)
    for room in rooms:
        socketio.emit('response_update', response_data, room=room)
    
    # Update database to mark this as the active question for this session
    # (This helps when audience members join or refresh the page)
    try:
        # Store the active question ID in the session record
        # Check if the attribute exists (in case migration hasn't been run)
        if hasattr(presentation_session, 'active_question_id'):
            presentation_session.active_question_id = question_id
            db.session.commit()
            print(f"Set question {question_id} as active for session {session_id}")
        else:
            print("Warning: active_question_id column not found - database migration may be needed")
    except Exception as e:
        print(f"Error updating active question ID: {e}")
        db.session.rollback()  # Roll back the transaction to avoid DB state issues
        # This is non-fatal, so continue
    
    # Check if this is an AJAX request or direct form submission
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        # For AJAX requests, return JSON with appropriate headers
        response = jsonify({
            'success': True,
            'message': f'Question {question_id} activated for session {session_id}',
            'question': question_details
        })
        # Add CORS headers to ensure the response can be processed by fetch
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,X-Requested-With')
        return response
    else:
        # For direct form submissions, redirect back to the presenter page
        # Add a success parameter to indicate the activation worked
        return redirect(url_for('present_session', session_id=session_id, activated='true'))

# Socket.IO events
@socketio.on('connect')
def handle_connect():
    print('Client connected')

@socketio.on('disconnect')
def handle_disconnect():
    print('Client disconnected')

@socketio.on('join_room')
def handle_join_room(data):
    room = data['room']
    join_room(room)
    print(f'Client joined room: {room}')
    
    # If this is a session room, add the client to both room types
    if room.startswith('session_'):
        session_id = room.split('_')[1]
        try:
            # Try to find the session code for this session ID
            presentation_session = Session.query.get(int(session_id))
            if presentation_session:
                # Also join the room by code
                code_room = f"code_{presentation_session.code}"
                join_room(code_room)
                print(f'Client also joined code room: {code_room}')
        except Exception as e:
            print(f"Error joining additional room: {e}")
    
    # Acknowledge the room join
    emit('room_joined', {'status': 'success', 'room': room})

@socketio.on('presenter_connected')
def handle_presenter_connected(data):
    session_id = data['session_id']
    room = f"session_{session_id}"
    join_room(room)
    
    # Emit to all clients in the room that the presenter is connected
    emit('presenter_status', {'connected': True}, room=room)

@socketio.on('activate_question')
def handle_activate_question(data):
    question_id = data['question_id']
    session_id = data['session_id']
    
    print(f"Question {question_id} activated for session {session_id}")
    
    # Find the session by ID
    presentation_session = Session.query.get(session_id)
    if not presentation_session:
        print(f"Error: Session {session_id} not found")
        return
    
    # Get session code for additional room targeting
    session_code = presentation_session.code
    
    # Define all possible room names for maximum delivery
    rooms = [
        f"session_{session_id}",      # Main room by session ID
        f"code_{session_code}",       # Room by session code
        f"s_{session_id}",            # Short format room
        f"c_{session_code}"           # Short format code room
    ]
    
    # Create activation data with all context
    activation_data = {
        'question_id': question_id,
        'session_id': session_id,
        'session_code': session_code,
        'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    }
    
    # Get the question details
    question = Question.query.get(question_id)
    
    # If the question exists, send its details
    if question:
        print(f"Sending question details for question {question_id}")
        question_details = {
            'id': question.id,
            'text': question.text,
            'type': question.type,
            'options': json.loads(question.options) if question.options else None
        }
        
        # Update all clients in all rooms
        for room in rooms:
            print(f"Broadcasting to room: {room}")
            emit('question_activated', activation_data, room=room, include_self=True)
            emit('question_details', question_details, room=room, include_self=True)
        
        # Also broadcast globally for redundancy 
        # In Flask-SocketIO, global broadcasts are done by omitting the room parameter
        emit('question_activated', activation_data)  # Global broadcast
        emit('question_details', question_details)   # Global broadcast
        
        # Fetch existing responses for this question
        responses = Response.query.filter_by(question_id=question_id).all()
        print(f"Found {len(responses)} existing responses for question {question_id}")
        
        response_data = {
            'question_id': question_id,
            'responses': [{'value': r.value, 'participant_id': r.participant_id} for r in responses]
        }
        
        # Update all clients with existing responses
        for room in rooms:
            emit('response_update', response_data, room=room, include_self=True)
        
        # Update database to mark this as the active question for this session
        try:
            # Check if the attribute exists (in case migration hasn't been run)
            if hasattr(presentation_session, 'active_question_id'):
                presentation_session.active_question_id = question_id
                db.session.commit()
                print(f"Updated session {session_id} with active question ID {question_id}")
            else:
                print("Warning: active_question_id column not found - database migration may be needed")
        except Exception as e:
            print(f"Error updating active question ID in database: {e}")
            db.session.rollback()
    else:
        print(f"Question {question_id} not found!")

@socketio.on('submit_response')
def handle_submit_response(data):
    question_id = data['question_id']
    session_id = data['session_id']
    value = data['value']
    participant_id = session.get('participant_id', str(uuid.uuid4()))
    
    print(f"Received response from participant {participant_id} for question {question_id}: {value}")
    
    # Create a new response
    new_response = Response(
        question_id=question_id,
        participant_id=participant_id,
        value=value,
        timestamp=datetime.now()
    )
    
    db.session.add(new_response)
    db.session.commit()
    
    # Find the session to get the session code
    presentation_session = Session.query.get(session_id)
    if not presentation_session:
        print(f"Error: Session {session_id} not found")
        emit('response_received', {'status': 'error', 'message': 'Session not found'})
        return
    
    session_code = presentation_session.code
    
    # Define all possible room names for maximum delivery
    rooms = [
        f"session_{session_id}",      # Main room by session ID
        f"code_{session_code}",       # Room by session code
        f"s_{session_id}",            # Short format room
        f"c_{session_code}"           # Short format code room
    ]
    
    # Create response data
    response_data = {
        'question_id': question_id,
        'value': value,
        'participant_id': participant_id
    }
    
    # Print debug information
    print(f"DEBUG RESPONSE: {response_data}")
    
    # Notify the presenter and other participants about the new response
    for room in rooms:
        print(f"DEBUG: Broadcasting response_received to room {room}")
        emit('response_received', response_data, room=room)
    
    # Get all responses for this question to update visualizations
    responses = Response.query.filter_by(question_id=question_id).all()
    print(f"Total responses for question {question_id}: {len(responses)}")
    
    response_data = {
        'question_id': question_id,
        'responses': [{'value': r.value, 'participant_id': r.participant_id} for r in responses]
    }
    
    # Update all clients with the latest response data
    for room in rooms:
        emit('response_update', response_data, room=room)
    
    # Also emit globally as a fallback
    emit('response_update', response_data)

@socketio.on('request_active_question')
def handle_request_active_question(data):
    session_id = data.get('session_id')
    session_code = data.get('session_code')
    print(f"Client requested active question for session {session_id} / code {session_code}")
    
    # Find the session by ID or code
    presentation_session = None
    if session_id:
        presentation_session = Session.query.get(session_id)
    elif session_code:
        presentation_session = Session.query.filter_by(code=session_code).first()
    
    if not presentation_session:
        print(f"Session not found with ID {session_id} or code {session_code}")
        emit('active_question', {'status': 'error', 'message': 'Session not found'})
        return
        
    # Get the most recent question as the active one
    questions = Question.query.filter_by(session_id=presentation_session.id).order_by(Question.id.desc()).all()
    
    if questions:
        active_question = questions[0]  # Most recent question
        print(f"Sending active question details for session {presentation_session.id}")
        
        question_details = {
            'id': active_question.id,
            'text': active_question.text,
            'type': active_question.type,
            'options': json.loads(active_question.options) if active_question.options else None
        }
        
        # Send the active question to the requesting client
        emit('question_details', question_details)
    else:
        print(f"No active question found for session {presentation_session.id}")
        emit('active_question', {'status': 'none'})

@socketio.on('request_question_details')
def handle_request_question_details(data):
    question_id = data['question_id']
    session_id = data.get('session_id')
    print(f"Client requested details for question {question_id}")
    
    # Get the question details
    question = Question.query.get(question_id)
    
    if question:
        print(f"Sending details for question {question_id}")
        question_details = {
            'id': question.id,
            'text': question.text,
            'type': question.type,
            'options': json.loads(question.options) if question.options else None
        }
        
        # Send question details to the requesting client
        emit('question_details', question_details)
        
        # If session ID is provided, also send responses
        if session_id:
            # Get responses for this question
            responses = Response.query.filter_by(question_id=question_id).all()
            response_data = {
                'question_id': question_id,
                'responses': [{'value': r.value, 'participant_id': r.participant_id} for r in responses]
            }
            
            # Send responses to the client
            emit('response_update', response_data)
    else:
        print(f"Question {question_id} not found!")
        emit('question_details_response', {'status': 'error', 'message': 'Question not found'})

@socketio.on('heartbeat')
def handle_heartbeat(data):
    # Simple ping-pong to keep the connection alive
    participant_id = data.get('participant_id', 'unknown')
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"Heartbeat received from participant {participant_id} at {timestamp}")
    
    # Send acknowledgment back to the client
    emit('heartbeat_ack', {
        'server_time': timestamp,
        'participant_id': participant_id
    })

if __name__ == '__main__':
    socketio.run(app, debug=True, allow_unsafe_werkzeug=True)

